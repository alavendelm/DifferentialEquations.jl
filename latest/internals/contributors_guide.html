<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contributor&#39;s Guide · DifferentialEquations.jl documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script></head><body><nav class="toc"><h1>DifferentialEquations.jl</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equation (ODE) Example</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equation (SDE) Example</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method Example</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method Example</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Examples</a></li></ul></li><li><span class="toctext">Solver Options</span><ul><li><a class="toctext" href="../solvers/ode_solve.html">Ordinary Differential Equation Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">Stochastic Differential Equation Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">Finite Element Method Poisson Equation Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">Finite Element Method Heat Equation Solvers</a></li><li><a class="toctext" href="../solvers/fdmstokes_solve.html">Finite Difference Method Stokes Equation Solvers</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/overview.html">Overview of DifferentialEquations.jl Usage</a></li><li><a class="toctext" href="../man/ODEProblem.html">Defining an ODE Problem</a></li><li><a class="toctext" href="../man/SDEProblem.html">Defining a SDE Problem</a></li><li><a class="toctext" href="../man/FEMProblem.html">Defining a FEM Problem</a></li><li><a class="toctext" href="../man/StokesProblem.html">Defining a Stokes Problem</a></li><li><a class="toctext" href="../man/mesh.html">Meshes</a></li><li><a class="toctext" href="../man/solution.html">The Solution Type</a></li><li><a class="toctext" href="../man/output_specification.html">Output Specification</a></li><li><a class="toctext" href="../man/plot.html">Plot Functions</a></li><li><a class="toctext" href="../man/function_definition_macros.html">Function Definition Macros</a></li><li><a class="toctext" href="../man/benchmarks.html">Benchmark Suite</a></li><li><a class="toctext" href="../man/convergence.html">Convergence Simulations</a></li><li><a class="toctext" href="../man/conditional_dependencies.html">Conditional Dependencies</a></li><li><a class="toctext" href="../man/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Internal Documentation</span><ul><li class="current"><a class="toctext" href="contributors_guide.html">Contributor&#39;s Guide</a><ul class="internal"><li><a class="toctext" href="#Developing-New-Solver-Algorithms-1">Developing New Solver Algorithms</a></li><li><a class="toctext" href="#Adding-Conditional-Dependencies-1">Adding Conditional Dependencies</a></li><li><a class="toctext" href="#Developing-A-New-Problem-1">Developing A New Problem</a></li><li><a class="toctext" href="#Other-Help-1">Other Help</a></li></ul></li><li><a class="toctext" href="fem_tools.html">Internal Finite Element Tools</a></li><li><a class="toctext" href="extras.html">Extra Functions</a></li><li><a class="toctext" href="solver_helpers.html">Solver Helpers</a></li><li><a class="toctext" href="notes_on_algorithms.html">Notes on Algorithms</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Internal Documentation</li><li><a href="contributors_guide.html">Contributor&#39;s Guide</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/tree/c2bdaccda5210a9344aa45bc7e87efd657a73d9e/docs/src/internals/contributors_guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Contributor's-Guide-1" href="#Contributor's-Guide-1">Contributor&#39;s Guide</a></h1><p>So you&#39;re looking to help out DifferentialEquations.jl? We&#39;d be happy to have your help. It is recommended you first discuss with some of the developers <a href="https://gitter.im/JuliaDiffEq/Lobby">on the Gitter channel</a> to make sure that you&#39;re up-to-date with current developments.</p><h2><a class="nav-anchor" id="Developing-New-Solver-Algorithms-1" href="#Developing-New-Solver-Algorithms-1">Developing New Solver Algorithms</a></h2><p>The easiest way to get started would be to add new solver algorithms. This is a pretty simple task as there are tools which put you right into the &quot;hot loop&quot;. For example, take a look at the ODE solver code. The mode <code>solve(::ODEProblem,::AbstractArray)</code> is glue code to a bunch of solver algorithms. The algorithms which are coded in DifferentialEquations.jl can be found in ode_integrators.jl. For example, take a look at the Midpoint method&#39;s implementation:</p><pre><code class="language-julia">function ode_solve{uType&lt;:Number,uEltype&lt;:Number,N,tType&lt;:Number,uEltypeNoUnits&lt;:Number,rateType&lt;:Number}(integrator::ODEIntegrator{:Midpoint,uType,uEltype,N,tType,uEltypeNoUnits,rateType})
  @ode_preamble
  halfΔt::tType = Δt/2
  @inbounds for T in Ts
    while t &lt; T
      @ode_loopheader
      u = u + Δt.*f(t+halfΔt,u+halfΔt.*f(t,u))
      @ode_numberloopfooter
    end
  end
  return u,t,timeseries,ts
end</code></pre><p>The available items are all unloaded from the <code>integrator</code> in the <code>@ode_preamble</code>. <code>@ode_loopheader</code> and <code>@ode_loopfooter</code> macros are for exiting at max iterations, and plugging into the Juno progressbar. These are all defined using the <code>@def</code> macro (they essentially copy-paste the code from the line which says <code>@def ode_loopheader begin ... end</code>). Note that the loopfooter code takes care of the code for doing the adaptive timestepping. All that is required for the adaptivity is that the algorithm computes an error estimate <code>EEst</code> each time, save the value <code>utmp</code> to be what will replace <code>u</code> if the step is not rejected, and add the algorithm&#39;s symbol is added to the dictionary <code>ODE_DIFFERENTIALEQUATIONSJL_ADAPTIVEALGS</code> in <code>ode_constants.jl</code>. If implicit solving is needed (via NLsolve), add the algorithm&#39;s symbol to <code>DIFFERENTIALEQUATIONSJL_IMPLICITALGS</code> and the conditional dependency will be supplied. Note that you may need more function arguments. Use another method as a template.</p><p>When the solver is completed, add a call to the solver in the glue code <code>solve(::ODEProblem,::AbstractArray)</code> (you will see all the others), add the symbol for the algorithm to <code>DIFFERENTIALEQUATIONSJL_ALGORITHMS</code>, and the order to <code>DIFFERENTIALEQUATIONSJL_ORDERS</code>. It&#39;s that quick! Lastly, add your method to the convergence tests in the appropriate /test file.  Feel free to implement any interesting or educational algorithm: they don&#39;t have to be the fastest and it is always is useful to have such algorithms (like Simpson&#39;s method) available for demonstration purposes.</p><p>Adding algorithms to the other problems is very similar.</p><h3><a class="nav-anchor" id="Extras-1" href="#Extras-1">Extras</a></h3><p>If the method is a FSAL method then it needs to be set it in <code>DIFFERENTIALEQUATIONSJL_FSALALGS</code> and <code>fsalfirst</code> should be defined before the loop, with <code>fsallast</code> what&#39;s pushed up to <code>fsalfirst</code> upon a successful step. See <code>:DP5</code> for an example.</p><p>It&#39;s usually wise to dispatch onto Number separately since that uses <code>f(t,u)</code> instead of <code>f(t,u,du)</code>. The dispatch is chosen by setting the <code>uType</code> and <code>rateType</code>, usually to either <code>&lt;:Number</code> or <code>&lt;:AbstractArray</code> (though they should be the same).</p><p>If tests fail due to units (i.e. SIUnits), don&#39;t worry. I would be willing to fix that up. To do so, you have to make sure you keep separate your <code>rateType</code>s and your <code>uType</code>s since the rates from <code>f</code> will have units of <code>u</code> but divided by a unit of time. If you simply try to write these into <code>u</code>, the units part will fail (normally you have to multiply by a <span>$Δt$</span>).</p><h2><a class="nav-anchor" id="Adding-Conditional-Dependencies-1" href="#Adding-Conditional-Dependencies-1">Adding Conditional Dependencies</a></h2><p>If your algorithm requires a conditional dependency (a package, but not one that everyone who uses DifferentialEquations.jl would need), you can add them as follows. Before the loop, add the line <code>initialize_backend(:PkgName)</code> where <code>:PkgName</code> is the same name as the package you wish to use. Then, in <code>general/backends.jl</code> add a dispatch to <code>init_package</code>. A common one would be:</p><pre><code class="language-julia">init_package(b::backend{:PkgName}) = @eval begin
      import PkgName
      export PkgName
    end</code></pre><p>Now inside your method you can use any function from the package via PkgName.function. The first time it is used it import the package (or tell the user to install it).</p><h2><a class="nav-anchor" id="Developing-A-New-Problem-1" href="#Developing-A-New-Problem-1">Developing A New Problem</a></h2><p>To develop a new problem, you need to make a new <code>DEProblem</code> and a new <code>DESolution</code>. The <code>DEProblem</code> type should hold all of the mathematical information about the problem, and the <code>DESolution</code> should hold all of the information for the solution. Then all that is required is to define a <code>solve(::DEProblem,*Extra Mesh Things*;kwargs)</code> which takes in the problem and returns a solution. To add plotting functionality, add a plot recipe for the solution type to <code>/general/plotrecipes</code>. For testing that the algorithm works, add a dispatch for <code>test_convergence</code> which makes a <code>ConvergenceSimulation</code> type. This type already has a plot recipe, so plotting functionality will already be embedded. This requires that your problem can take in a true solution, and has a field <code>errors</code> which is a dictionary of symbols for the different error estimates (L2,L infinity, etc.)</p><h2><a class="nav-anchor" id="Other-Help-1" href="#Other-Help-1">Other Help</a></h2><p>There&#39;s always more to be. Improved plot recipes and new series recipes are always nice to add more default plots. It is always helpful to have benchmarks between different algorithms to see &quot;which is best&quot;. Adding examples IJulia notebooks to <code>examples/</code> is a good way to share knowledge about DifferentialEquations.jl. Also, please feel free to comb through the solvers and look for ways to make them more efficient. Lastly, the documentation could always use improvements. If you have any questions on how to help, just ask them in the Gitter!</p><footer><hr/><a class="previous" href="../man/progress_bar.html"><span class="direction">Previous</span><span class="title">Juno Progress Bar Integration</span></a><a class="next" href="fem_tools.html"><span class="direction">Next</span><span class="title">Internal Finite Element Tools</span></a></footer></article></body></html>
